# CodingTest
This is an auto push repository for Baekjoon Online Judge created with [BaekjoonHub](https://github.com/BaekjoonHub/BaekjoonHub).

수수행 시간을 고려할 때 1초에 약 2천만번 정도의 연산을 수행할 수 있다고 가정하자.

코딩 테스트 문제에서 시간 제한은 통상 1~5초 가량임.

<aside>
💡

문제 해결 과정

1. 지문 읽기 및 컴퓨터적 사고
2. 요구사항(복잡도) 분석
3. 문제 해결을 위한 아이디어 찾기 ⇒ 바로 코딩하지 말고 분석을 해보는 것이 중요
4. 소스코드 설계 및 코딩
</aside>

# 🥊 요구사항 확인

문제에서 가장 먼저 확인할 것은 시간 제한이다. 데이터의 개수 N의 범위가 주어지기 때문에 데이터의 조건을 확인하고, 수행 시간 조건을 확인한 후 알고리즘을 선택하자.

예를 들어 시간 제한이 1초인 문제의 경우

1. N의 범위가 500인 경우 : 시간 복잡도가 O(N^3)인 알고리즘을 설계하면 문제를 풀 수 있다.
2. N의 범위가 2,000인 경우 : 시간 복잡도가 O(N^2)인 알고리즘을 설계하면 문제를 풀 수 있다.
3. N의 범위가 100,000인 경우 : 시간 복잡도가 O(NlogN)인 알고리즘을 설게하면 문제를 풀 수 있다.

## ✨ 수행 시간 측정

```python
import time
start_time = time.time() #측정 시작

#프로그램 소스코드

end_time = time.time() #측정 종료
print("time : ", end_time - start_time) #수행 시간 출력
```

# 💡 자료형

- 모든 프로그래밍은 결국 데이터를 다루는 행위이므로 자료형에 대한 이해가 필요.

1. 정수형

```python
a = 1000
print(a)

a = -7
print(a)

a = 0
print(a)
```

1. 실수형

```python
a = 5.4
print(a)

# 0.7
a = .7
print(a)

# 5.0
a = 5.
print(a)

# -0.92
a = -.92
print(a)
```

💡 지수 표현 방식

- 파이썬에서는 e나 E를 이용한 지수 표현 방식을 이용할 수 있다. e나 E 다음에 오는 수는 10의 지수부를 의미.
- 예를 들어 1e9라고 입력하게 되면 10의 9 제곱을 의미하게 된다. 단, 지수 표현 방식은 실수형 데이터로 처리된다. 보통 임의의 큰 수를 표현하기 위해 사용한다. 예를 들어 최단 경로 알고리즘에서 도달할 수 없는 노드에 대하여 최단 거리를 무한으로 설정하곤 하는데, 이때 가능한 최댓값이 10억 미만이라면 무한의 값으로 1e9를 사용할 수 있다.

```python
a = 1e9
print(a)

# 752.5
a = 75.25e1
print(a)

#3.954
a = 3954e-3
print(a)

# 실수형 데이터를 정수형 데이터로 변환
a = int(1e9)
print(a)
```

💡 실수형 더 알아보기

- 실수형을 저장하기 위해 4바이트, 8바이트 등 고정된 크기의 메모리를 할당하므로, 컴퓨터 시스템은 실수 정보를 표현하는 정확도에 한계를 갖는다.
- 10진수에서는 0.3 + 0.6 = 0.9를 정확하게 표현할 수 있지만, 2진수에서는 0.9를 정확히 표현할 방법이 없다. 이에 따라 미세한 오차가 발생할 수 있다.
- 실수값 비교를 위해 round() 함수를 사용.
- round(123.456, 2) = 123.46이 됨.

```python
a = 0.3 + 0.6
#0.899999999999
print(a)

if a == 0.9:
	print(True)
else:
	print(False)
	
#False

a = 0.3 + 0.6
print(round(a, 3))

if round(a, 3) == 0.9:
	print(True)
else:
	print(False)
	
#True
```

💡 수 자료형 연산

- 나누기 연산자(/)를 사용할 때 파이썬은 나눠진 결과를 실수형으로 반환한다. 파이썬에서는 몫을 얻기 위해 몫 연산자(//)를 사용한다

```python
#3.3333333
a = 10 / 3
print(a)

#3
a = 10 // 3
print(a)

#125 (거듭 제곱)
a = 5 ** 3
print(a)

#제곱근
a = 5 ** 0.5
print(a)
```

# 💡리스트

- 여러 개의 데이터를 연속적으로 담아 처리하기 위해 사용하는 자료형. C나 자바에서의 Array의 기능 및 연결 리스트와 유사한 기능을 지원.
- vector와 기능적으로 유사하다. 리스트 대신에 배열 혹은 테이블이라고도 부름.
- 대괄호 안에 원소를 넣어 초기화하며, 쉼표로 원소를 구분.
- 비어 있는 리스트를 선언하고자 할 때는 list() 혹은 간단히 []을 사용.
- 인덱스 값을 입력하여 리스트의 특정한 원소에 접근하는 것을 인덱싱이라고 함. 인덱스 값은 양의 정수와 음의 정수 둘 다 사용 가능.

```python
a = [1, 2, 3, 4, 5, 6, 7]
print(a)

# 4번째 원소 4 출력
print(a[3])

# 0이 10개 출력됨.
n = 10
a = [0] * n
print(a)

a = [1, 2, 3, 4, 5, 6, 7]

# 뒤에서 첫번째 원소 출력 7
print(a[-1)

# 뒤에서 세번째 원소 출력 5
print(a[-3])
```

- 리스트에서 연속적인 위치를 갖는 원소들을 가져와야 할 때는 슬라이싱을 이용
    - 대괄호 안에 콜론을 넣어서 시작 인덱스와 끝 인덱스를 설정. 끝 인덱스는 실제 인덱스보다 1 더 크게 설정해야 함.

```python
a = [1, 2, 3, 4, 5, 6, 7]

# 2, 3, 4
print(a[1:4])

# 3, 4, 5, 6
print(a[2:-1])
```

- 리스트 컴프리헨션 : 리스트를 초기화하는 방법 중 하나
    - 대괄호 안에 조건문과 반복문을 적용하여 리스트를 초기화.
    - 2차원 리스트를 초기화할 때 효과적으로 사용됨.
    - 특히 NxM 크기의 2차원 리스트를 한 번에 초기화 해야 할 때 매우 유용하다

```python
array = [i for i in range(10)]

# 0부터 9까지의 수를 포함하는 리스트
print(array)

array = [i for i in range(20) if i % 2 == 1]

# 0~19까지의 수 중에서 홀수만 포함하는 리스트
print(array)

array = [i * i for i in range(1, 10)]

# 1~9까지의 수들의 제곱 값을 포함하는 리스트
print(array)

n = 5
m = 7
# 2차원 리스트 초기화
# 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 언더바를 사용
array = [[0] * m for _ in range(n)]
print(array)

# 잘못된 예시. 파이썬에서는 리스트를 생성할 때 객체로 생성. 근데 이것에 대해 n을 곱하면, n번
# 만큼 참조값을 복사하는 것과 동일. [0] * m 이라는 객체를 n번 나열하는 것. 원소 1개만 바꿔도
# n개의 원소가 모두 바뀌게 된다.
array = [[0] * m] * n
print(array)
```

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/31b3a542-8874-4476-bec1-3253a9474a08/cb4e7397-a406-4e2d-86ad-a94f34b07e28/image.png)

```python
a = [1, 4, 3]
print(a)

a.append(2)
print("삽입", a)

a.sort()
print("오름차순 정렬", a)

a.sort(reverse = True)
print("내림차순 정렬", a)

a = [4, 3, 2, 1]

a.reverse()
print("원소 뒤집기", a)
# 1, 2, 3, 4

a.insert(2, 55)
print("원소 삽입", a)
# 1, 2, 55, 3, 4

print("값이 3인 데이터 개수", a.count(3))

a.remove(2)
print("2인 데이터 삭제", a)

a = [1, 2, 3, 4, 5, 5, 5]
remove_set = {3, 5} # 집합 자료형

# remove_list에 포함되지 않은 값만을 저장
result = [i for i in a if i not in remove_set]
print(result) # 1, 2, 4
```
